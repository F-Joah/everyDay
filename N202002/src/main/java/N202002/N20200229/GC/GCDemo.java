package N202002.N20200229.GC;

/**
 *
 *  1、GC是什么？
 *      1.1、分代收集算法
 *      1.2、体现：
 *          1.2.1、次数上频繁收集Young区
 *          1.2.2、次数上较少收集Old区
 *          1.2.3、基本不动元空间
 *
 *  2、GC四大算法
 *      2.1、引用计数法
 *          缺点：
 *              每次对 对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗
 *              较难处理循环引用
 *          JVM 的实现一般不采用这种方式
 *
 *      2.2、复制算法(Copying)
 *          2.2.1、年轻代   中使用的是 Minor GC ，这种 GC 算法采用的是复制算法(Copying)
 *          2.2.2、What?
 *              2.2.2.1、原理
 *                  Minor GC 的过程 （复制 -> 清空 -> 互换）
 *          2.2.3、优势
 *                  整体拷贝，没有碎片
 *  *               效率高
 *          2.2.4、劣势
 *                 2.2.4.1、它浪费了一半的内存，
 *                 2.2.4.2、如果对象的存活率很高，如果极端一点，假设 100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。
 *                      复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。所以从这一点描述不难看出，复制算法要想使用，
 *                      最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服 50%内存的浪费
 *      2.3、标记清除(Mark-Sweep)
 *          2.3.1、老年代   一般是由标记清除，或者是标记清楚与标记整理的混合实现
 *          2.3.2、what?
 *              先标记要回收的，然后统一回收
 *              标记：从引用根节点开始标记遍历先标记出要回收的对象
 *              清除：遍历整个堆，把标记的对象清除
 *          2.3.3、优势
 *              不需要额外空间
 *          2.3.4、劣势
 *              效率比较低（递归与全堆对象遍历）
 *              此算法需要暂停整个应用，会产生内存碎片
 *
 *      2.4、标记压缩(Mark-Compact)
 *          2.4.1、老年代   一般是由标记清除与标记整理的混合实现
 *          2.4.2、what?
 *              先标记，然后压缩到一起，留出空闲内存
 *          2.4.3、标记清除压缩（Mark-Sweep-Compact）
 *
 *
 *      2.5、比较：
 *          内存效率： 复制算法 > 标记清除算法 > 标记整理算法 (此处的效率只是简单的对比时间复杂度，实际情况不一定如此)
 *          内存整齐度： 复制算法 = 标记整理算法 > 标记清除算法
 *          内存利用率： 标记整理算法 = 标记清除算法 > 复制算法
 *
 *          可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理 算法相对来说平滑一些
 *          但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程
 *
 *          有没有一种最优算法？
 *              答：目前没有！！！ 没有最好的算法，只有最合适的算法 ==============>分代收集算法
 *
 *              年轻代（Young Gen）
 *                  年轻代特点是区域相对老年代较小，对象存活率较低
 *                  这种情况，复制算法  的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因而很适合用于年轻代的回收
 *              老年代（Tenure Gen）
 *                  老年代的特点是区域较大，对象存活率高
 *                  存在大量存活率高的对象，复制算法明显变得不合适。一般由标记清除或者是标记清除与标记整理的混合
 *
 *
 * @author Joah
 * @time 2020/2/29 21:19
 */
public class GCDemo {

    public static void main(String[] args) {

    }
}
